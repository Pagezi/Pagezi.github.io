<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Pagezi</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2020-10-05T15:20:46.853Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>爬格子</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《Effective》读书笔记</title>
    <link href="http://example.com/posts/24218/"/>
    <id>http://example.com/posts/24218/</id>
    <published>2020-10-04T03:14:56.000Z</published>
    <updated>2020-10-05T15:20:46.853Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h2 id="第一章-让自己习惯C"><a href="#第一章-让自己习惯C" class="headerlink" title="第一章 让自己习惯C++"></a>第一章 让自己习惯C++</h2><h3 id="T01：视C-为一个语言联邦"><a href="#T01：视C-为一个语言联邦" class="headerlink" title="T01：视C++为一个语言联邦"></a>T01：视C++为一个语言联邦</h3><p>略</p><h3 id="T02：尽量以const-enum-inline替换-define"><a href="#T02：尽量以const-enum-inline替换-define" class="headerlink" title="T02：尽量以const,enum,inline替换#define"></a>T02：尽量以const,enum,inline替换#define</h3><p><strong>单纯的常量，改用const,enums替换</strong><br>这样一个宏定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ASPECT_RATIO 1.653</span></span><br></pre></td></tr></table></figure><p>在编译器开始处理源码的时候，这个ASPECT_RATIO符号可能就被预处理器移走了，可能没有获得此符号表，运用这个常量出现一个错误信息的时候，错误信息可能会提到是1.653而不是ASPECT_RATIO，会让人很懵逼<br>可以用这种方式去替换</p><a id="more"></a><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Test1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    static <span class="keyword">const</span> <span class="built_in">int</span> num = <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>enum hack的用法，主要适用于一些旧的编译器不支持在类中初始化static的变量，但是又必须完成这个变量的初始化的时候的一种用法</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="symbol">Test1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> &#123;NumTurns = <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">int</span> scores[NumTurns];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>形式函数的宏，改用inline替换</strong><br>在下面这种情况下，用a和b谁大去判断函数f会调用哪个，b的不同会导致a的累加次数不同，<strong><em>这种宏的使用方法非常不好</em>！</strong></p><figure class="highlight c++"><figcaption><span>哈哈</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CALL_WITH_MAX(a, b) f((a)&gt;(b)?(a):(b))</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">5</span>,b=<span class="number">0</span>;</span><br><span class="line">    CALL_WITH_MAX(++a,b);   <span class="comment">// a=7</span></span><br><span class="line">    CALL_WITH_MAX(++a,b+<span class="number">10</span>); <span class="comment">// a=6</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a &lt;&lt;<span class="string">","</span>&lt;&lt;b&lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用这种方式去替代</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">callWithMax</span><span class="params">(<span class="keyword">const</span> T&amp; a, <span class="keyword">const</span> T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f(a&gt;b?a:b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="T03：可能使用const"><a href="#T03：可能使用const" class="headerlink" title="T03：可能使用const"></a>T03：可能使用const</h3><p><strong>const的用法</strong><br>const出现在*号左边，表示被指物是常量<br>const出现在*号右边，表示指针是常量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> hello[] = <span class="string">"hello"</span>;</span><br><span class="line">    <span class="keyword">char</span> world[] = <span class="string">"world"</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* p1 =hello;    <span class="comment">// 指针指向的对象是常量  *p1= "1";是不合法的</span></span><br><span class="line">    <span class="keyword">char</span>* <span class="keyword">const</span> p2 =hello;    <span class="comment">// 指针本身是常量，不能指向别的地址  p2 = world;是不合法的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>STL里的迭代器</strong>  </p><p>区别于const vector<int>::iterator和vector<int>::const_iterator，前者指针是常量，后者被指向物是常量。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">//int a[] = &#123;1,2,3,4,5&#125;;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec_list = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = vec_list.<span class="built_in">begin</span>();  <span class="comment">// it作用像 T* const 指针本身不能指向别处  it = vec_list.end();不合法</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it2 = vec_list.<span class="built_in">begin</span>();  <span class="comment">// it2作用像 const T*  不能改变it指向的内容  *it2 = 5;不合法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>const成员函数</strong><br>const成员函数可以用在const对象上。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> a)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"gogo:"</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"hello:"</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b =<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> A a;</span><br><span class="line">    a.<span class="built_in">print</span>(b); <span class="comment">// 可以调用成功</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> A c;</span><br><span class="line">    c.hello(b);  <span class="comment">// 会报错，意思是不能调用不是const的成员函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>bitwise constness 和 logical constness<br>bitwise constness认为成员函数在不更改任何成员变量时才能被称为const， 但是像那种只有指针隶属于对象，而这个函数又修改了指针指向的物体时，编译器是不会报错的，但是实际上这种行为会导致运行时候有问题。<br>logical constness<br><strong>const和no-const成员避免重复</strong><br>non-const版本函数调用—&gt;const版本函数，来减少代码量！这样的调用是可行的，但是反过来non-const版本函数调用&lt;—const版本函数是不可行的，因为non-const版本函数不受约束可能改东西，不符合const版本函数的性质。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>&amp; <span class="title">print</span><span class="params">(<span class="keyword">int</span> a)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// todo:写一堆相同的东西</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"gogo const:"</span>&lt;&lt;buff[a]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> buff[a];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">char</span>&amp; <span class="title">print</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>&amp;&gt;(<span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> A&amp;&gt;(*<span class="keyword">this</span>).<span class="built_in">print</span>(a));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> buff= <span class="string">"hello"</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> b =<span class="number">1</span>;</span><br><span class="line">    A a;</span><br><span class="line">    a.<span class="built_in">print</span>(b); <span class="comment">// 可以调用成功</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>static_cast把A转换成const A，然后调用const版本的print返回一个const char&amp;,const_cast在把const去掉，然后返回。</p><h3 id="T04：确定对象使用前被初始化"><a href="#T04：确定对象使用前被初始化" class="headerlink" title="T04：确定对象使用前被初始化"></a>T04：确定对象使用前被初始化</h3><p>这里需要知道一个原则：永远在使用一个对象前将它初始化。但是不要混淆赋值(assignment)和初始化(initialization)两个概念。</p><p>用类去创建一个对象，成员变量的初始化会放在构造函数之前，按照下面代码里的第一种写法，会经历初始化+赋值两个阶段，第二写法只经历初始化阶段，效率上要更高一些，如果是内置类型，经历初始化+赋值两个阶段效率上影响不会太大，但是如果一些用户的自定义类型，可能在效率上回相差很多。所以，在此建议：总是使用<strong>成员初始化列表</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ABEntry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ABEntry()</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ABEntry(<span class="keyword">const</span> <span class="built_in">string</span>&amp;name, <span class="keyword">const</span> <span class="built_in">string</span> address, <span class="keyword">const</span> <span class="keyword">int</span>&amp; phoneNum)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//这个是赋值</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;theName = name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;theAddress = address;</span><br><span class="line">        <span class="keyword">this</span>-&gt;thePhoneNum = phoneNum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ABEntry(<span class="keyword">const</span> <span class="built_in">string</span>&amp;name, <span class="keyword">const</span> <span class="built_in">string</span> address, <span class="keyword">const</span> <span class="keyword">int</span>&amp; phoneNum, <span class="keyword">const</span> <span class="built_in">string</span>&amp; ii):theName(name),theAddress(address),thePhoneNum(phoneNum)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//这个是初始化</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> theName;</span><br><span class="line">    <span class="built_in">string</span> theAddress;</span><br><span class="line">    <span class="keyword">int</span> thePhoneNum;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ABEntry A;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第二章-构造-析构-赋值运算"><a href="#第二章-构造-析构-赋值运算" class="headerlink" title="第二章 构造/析构/赋值运算"></a>第二章 构造/析构/赋值运算</h2><h3 id="T05：了解C-默默编写并调用了哪些函数"><a href="#T05：了解C-默默编写并调用了哪些函数" class="headerlink" title="T05：了解C++默默编写并调用了哪些函数"></a>T05：了解C++默默编写并调用了哪些函数</h3><p>当默认写下一个空大类的时候，编译器会自动帮我们声明四个函数：default构造函数、copy构造函数、析构函数、copy assignment操作符，但是只有这些函数需要被调用的时候，编译器才会创建出来。</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="keyword">Test</span></span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    <span class="keyword">Test</span>()&#123;&#125;</span><br><span class="line">    <span class="keyword">Test</span>(<span class="keyword">const</span> <span class="keyword">Test</span>&amp; t)&#123;&#125;</span><br><span class="line">    ~<span class="keyword">Test</span>()&#123;&#125;</span><br><span class="line">    <span class="keyword">Test</span>&amp; operator=(<span class="keyword">const</span> <span class="keyword">Test</span>&amp; rhs)&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>举个例子，下面的会自动创建copy构造函数和copy assignment操作符，这两个默认的copy会将每一个来源对象的non-static成员变量拷贝到目标对象。TODO:这里经过实践发现static也会拷贝？？？ 实际是怎么样的呢？？</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Test(<span class="keyword">const</span> <span class="built_in">string</span>&amp; n,<span class="keyword">const</span> T&amp; t):name(n),object(t)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Test(const Test&amp; t)&#123;&#125;</span></span><br><span class="line">    ~Test()&#123;&#125;</span><br><span class="line">    <span class="comment">//Test&amp; operator=(const Test&amp; rhs)&#123;&#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;name&lt;&lt;<span class="built_in">endl</span>&lt;&lt;object&lt;&lt;<span class="built_in">endl</span>&lt;&lt;staObject&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> T staObject;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    T object;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T Test&lt;T&gt;::staObject =<span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Test&lt;int&gt;::staObject =5;</span></span><br><span class="line">    <span class="function">Test&lt;<span class="keyword">int</span>&gt; <span class="title">A</span><span class="params">(<span class="string">"int"</span>, <span class="number">666</span>)</span></span>;</span><br><span class="line">    A.staObject =<span class="number">8</span>;</span><br><span class="line">    A.<span class="built_in">print</span>();</span><br><span class="line">    Test&lt;<span class="keyword">int</span>&gt; B=A;</span><br><span class="line">    B.<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>copy assignment操作符的自动生成必须满足两个条件：1.生成出的代码合法；2.有机会证明有意义。 比如下面一种情况，编译器会拒绝生成copy assignment操作符。因为t2=t1的这个操作，会让t2.nameValue指向t1.nameValue,但是这样是非法的，C++不允许让refrence改指向不同的对象，t2.object和会变为t1.object,这也是非法的，因为const的变量是只读的。这种只有自己手动定义一个copy assignment操作符啦</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Test(<span class="built_in">string</span>&amp; name,<span class="keyword">const</span> T value):nameValue(name),object(value)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//  Test&amp; operator=(const Test&amp; rhs)</span></span><br><span class="line"><span class="comment">//  &#123;</span></span><br><span class="line"><span class="comment">//      this-&gt;nameValue = rhs.nameValue;</span></span><br><span class="line"><span class="comment">//      return *this;</span></span><br><span class="line"><span class="comment">//  &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span>&amp; nameValue;</span><br><span class="line">    <span class="keyword">const</span> T object;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> dog =<span class="string">"dog"</span>;</span><br><span class="line">    <span class="built_in">string</span> cat =<span class="string">"cat"</span>;</span><br><span class="line">    <span class="function">Test&lt;<span class="keyword">int</span>&gt; <span class="title">t1</span><span class="params">(dog,<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">Test&lt;<span class="keyword">int</span>&gt; <span class="title">t2</span><span class="params">(cat,<span class="number">2</span>)</span></span>;</span><br><span class="line">    t2=t1;  <span class="comment">// 非法m，会提示copy assignment被删除</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于C++不允许让refrence改指向不同的对象该如何理解呢？<br>这里发现一个问题,来看下面的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">nameValue</span><span class="params">(<span class="string">"12345"</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">nameValue1</span><span class="params">(<span class="string">"66666"</span>)</span></span>;</span><br><span class="line">    <span class="built_in">string</span>&amp; re=nameValue;  <span class="comment">//此时re应该是12345</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;re&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    re= nameValue1;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;re&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//    cout&lt;&lt;&amp;re&lt;&lt;endl&lt;&lt;&amp;nameValue&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//    cout&lt;&lt;re&lt;&lt;endl&lt;&lt;nameValue&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一次输出12345，第二次输出66666。说好的引用的指向不变？ 可是这里为什么又变了呢。<br>其实实际上re= nameValue1是一次赋值操作，nameValue也被改变了，可以分别输出&amp;re和&amp;nameValue的地址还有各自的变量看一下就会很明了，&amp;re和&amp;nameValue还是相同的。记住一句话：引用即别名！<br>如果父类的copy assignment操作符是个private,那么子类不会为他自动生成一个copy assignment操作符。</p><h3 id="T06：若不想使用编译器自动生成的函数，就该明确拒绝"><a href="#T06：若不想使用编译器自动生成的函数，就该明确拒绝" class="headerlink" title="T06：若不想使用编译器自动生成的函数，就该明确拒绝"></a>T06：若不想使用编译器自动生成的函数，就该明确拒绝</h3><p>如果我们编写一个类，但是要让这个类产生的对象是不可赋值的，该怎么做。由T05可知，当默认写下一个空大类的时候，编译器会自动帮我们在调用的时候声明四个函数：default构造函数、copy构造函数、析构函数、copy assignment操作符。所以我们要做的就是对copy构造函数和copy assignment操作符做屏蔽。<br><strong>方法1：将这两个函数声明为private</strong><br>这个方法可行，但是不是绝对安全的，成员函数和友元函数还是可以调用到。<br><strong>方法2：专门设计一个类，类中把copy构造函数和copy assignment操作符设为私有，并继承该类</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Uncopyable</span>&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Uncopyable()&#123;&#125;</span><br><span class="line">    ~Uncopyable()&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Uncopyable(<span class="keyword">const</span> Uncopyable&amp;);</span><br><span class="line">    Uncopyable&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Uncopyable&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span><span class="keyword">private</span> Uncopyable&#123;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    Test t1;</span><br><span class="line">    Test t2;</span><br><span class="line">    t1=t2;  <span class="comment">// 编译前就会报错 Object of type 'Test' cannot be assigned because its copy assignment operator is implicitly deleted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据T12所说，对Test赋值的时候，会调用父类的对应函数，但是父类对应函数是private，所以被拒绝。</p><h3 id="T07：为多态基类声明virtual析构函数"><a href="#T07：为多态基类声明virtual析构函数" class="headerlink" title="T07：为多态基类声明virtual析构函数"></a>T07：为多态基类声明virtual析构函数</h3><p><strong>当class中至少有一个虚构函数的时候才将这个class的析构函数声明为virtual（这样子的写法，是想利用多态这个性质），因为有virtual成员函数的类一般都是多态基类（还有一些类，他就是base class而已，并不想要多态的性质，比如T06的Uncopyable)</strong><br>在工厂模式下，一个基类的指针可以指向派生类的实例对象，在C++中为了避免内存泄漏和其他资源，需要讲指针指向的对象给delete掉，因为他是在堆内存上的。看下面的代码，FirstClass是Base的派生类，first是FirstClass对象，这个对象由一个Base指针指向，如果Base类中的析构函数不是virtual 就会导致first对象中只销毁了Base部分，FirstClass部分没有被销毁。这就造成了<strong>局部销毁</strong>的现象！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="keyword">virtual</span> ~Base()&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"leave base"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Base* <span class="title">getClass</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="keyword">virtual</span> <span class="title">gogo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"gogo"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FirstClass</span>:</span><span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~FirstClass()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"leave FirstClass"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    void gogo()</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        cout&lt;&lt;"toto"&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    FirstClass first;</span><br><span class="line">    Base* b = &amp;first;</span><br><span class="line">    <span class="keyword">delete</span> b;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"end"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// (*b).gogo()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不要继承STL里的容器，因为他们的析构函数不是virtual，会出现上述的问题。<br><strong>虚函数</strong><br>上诉例子中 gogo这个函数就是一个虚函数，如果调用这一句(<em>b).gogo()  还是会输出FirstClass中的gogo，即使这个指针是一个Base类型的。引入一个概念一个类函数的调用并不是在编译时刻被确定的，而是在运行时刻被确定的。由于编写代码的时候并不能确定被调用的是基类的函数还是哪个派生类的函数，所以被成为”虚”函数。<br>*</em>纯虚函数**<br>virtual void funtion1()=0  它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。在基类中实现纯虚函数的方法是在函数原型后加”=0”。 可以作为一个接口用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~Base()=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="keyword">virtual</span> <span class="title">gogo</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line">Base::~Base()&#123;&#125;  <span class="comment">// 这里必须有个实现，没有实现的话会报错</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FirstClass</span>:</span><span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~FirstClass()&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"leave FirstClass"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">gogo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"toto"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    FirstClass first;</span><br><span class="line">    Base* b=&amp;first;</span><br><span class="line">    (*b).gogo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="T08：别让异常逃离析构函数"><a href="#T08：别让异常逃离析构函数" class="headerlink" title="T08：别让异常逃离析构函数"></a>T08：别让异常逃离析构函数</h3><h3 id="T09：绝不在构造和析构函数过程中调用virtual函数"><a href="#T09：绝不在构造和析构函数过程中调用virtual函数" class="headerlink" title="T09：绝不在构造和析构函数过程中调用virtual函数"></a>T09：绝不在构造和析构函数过程中调用virtual函数</h3><h3 id="T10：令operator-返回一个reference-to-this"><a href="#T10：令operator-返回一个reference-to-this" class="headerlink" title="T10：令operator=返回一个reference to *this"></a>T10：令operator=返回一个reference to *this</h3><p>为了实现连锁赋值，赋值操作符必须返回一个reference指向操作符左侧的实参。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;value = rhs.value;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// 看这儿</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> value=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    Widget w1;</span><br><span class="line">    w1.value =<span class="number">1</span>;</span><br><span class="line">    Widget w2,w3,w4;</span><br><span class="line">    w2=w3=w4=w1;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;w4.value&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="T11：operator-中处理自我赋值"><a href="#T11：operator-中处理自我赋值" class="headerlink" title="T11：operator=中处理自我赋值"></a>T11：operator=中处理自我赋值</h3><p>在代码中很有可能会存在一些隐式的自我赋值，比如</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a<span class="comment">[i]</span>==a<span class="comment">[j]</span></span><br></pre></td></tr></table></figure><p>如果i和j的位置指向同一个对象，就很有可能产生自我赋值，再比如说,如果指针px和py指向同一个对象，那也是自我赋值。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*<span class="attribute">px</span>=*py</span><br></pre></td></tr></table></figure><p>更进一步说，如果两个对象来自同一个继承体系，虽然他们没有被声明为同一个类型，但是有可能是同一个对象</p><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class <span class="type">Base</span><span class="meta">&#123;...&#125;</span>;</span><br><span class="line">class <span class="type">Derived</span>:public <span class="type">Base</span><span class="meta">&#123;...&#125;</span>;</span><br><span class="line"><span class="built_in">void</span> doSomething(<span class="keyword">const</span> <span class="type">Base</span>&amp; rb,<span class="type">Derived</span>* pd);  // 有可能是同一个对象</span><br></pre></td></tr></table></figure><p>所以面对这种情况必须要保证&lt;自我赋值安全的&gt;，不要掉入在停止使用资源之前释放了他的陷进。<br>举如下例子，看Widget的copying函数，如果rhs和 <em>this相同，在这一步tex已经被删除了，用删除的tex取赋值，不合适！况且下面的做法也不具备异常安全性，如果tex = new Texture(</em>rhs.tex);过程中产生了异常，那么tex会指向被删除的tex（总而言之，就是删除太早了）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Texture</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Texture(<span class="keyword">const</span> Texture&amp; rhs)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;a=rhs.a;  <span class="comment">// 会报错</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">&#125;;  <span class="comment">// 假设他是一个贴图文件</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Widget&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> tex;  <span class="comment">//如果rhs和 *this相同，在这一步tex已经被删除了，用删除的tex取赋值，不合适</span></span><br><span class="line">        tex = <span class="keyword">new</span> Texture(*rhs.tex);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Texture * tex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    Widget w1;</span><br><span class="line">    w1=w1;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"finish"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决办法1：加入证同测试</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>==&amp;rhs)  <span class="comment">//加入证同测试</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    delete tex;</span><br><span class="line">    tex = new Texture(*rhs.tex);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决办法2；先对原来的Texture做一份复制，在删除原来的Bitmap</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Widget&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    Texture* texOri = tex;</span><br><span class="line">    <span class="keyword">this</span>-&gt;tex = new Texture(*rhs.tex);</span><br><span class="line">    delete texOri;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决办法3： copy and swap技术  #todo: T29再详细说明</p><h3 id="T12：复制对象时勿忘其每一个成分"><a href="#T12：复制对象时勿忘其每一个成分" class="headerlink" title="T12：复制对象时勿忘其每一个成分"></a>T12：复制对象时勿忘其每一个成分</h3><p>编辑器生成版的copying函数（copy构造函数和copy assignment操作符）会将被拷贝对象的所有成员都做一份拷贝，其中包含base classes父类们的成员变量，所以这个时候就会自动调用父类的copying函数。但是如果用户自己定义copying函数,是不会自动调用，需要用户自己手动调用。一定要记住：（1）复制所有local成员变量;(2).调用所有base classes内适当的copying函数;</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Father&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Father&amp; rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        a = rhs.a;</span><br><span class="line">        b = rhs.b;</span><br><span class="line">        c = rhs.c;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="built_in">string</span> c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;a=a;</span><br><span class="line">        <span class="keyword">this</span>-&gt;b=b;</span><br><span class="line">        <span class="keyword">this</span>-&gt;c=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printf</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    <span class="built_in">string</span> c=<span class="string">"No"</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span>:</span><span class="keyword">public</span> Father&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Son()&#123;&#125;</span><br><span class="line">    Son(<span class="keyword">const</span> Son&amp; rhs):Father(rhs),d(rhs.d)&#123;&#125;</span><br><span class="line">    Son&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Son&amp; rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        d = rhs.d;</span><br><span class="line">        Father::<span class="keyword">operator</span>=(rhs);  <span class="comment">// 注释掉输出 1 1 No  解开注释输出  1 2 Yes</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">    Son s1;</span><br><span class="line">    s1.setValue(<span class="number">1</span>, <span class="number">2</span>, <span class="string">"Yes"</span>);</span><br><span class="line">    Son s2;</span><br><span class="line">    s2=s1;</span><br><span class="line">    s2.<span class="built_in">printf</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>copy构造函数和coping assignment操作符里面的代码可能会比较相似。但是切记！，copy构造函数和coping assignment操作符不要相互调用，最好的方法是给相同的代码新建一个private的成员函数。</p><h2 id="第三章-资源管理"><a href="#第三章-资源管理" class="headerlink" title="第三章 资源管理"></a>第三章 资源管理</h2><h3 id="T13：以对象管理资源"><a href="#T13：以对象管理资源" class="headerlink" title="T13：以对象管理资源"></a>T13：以对象管理资源</h3><h3 id="T14：在资源管理类中小心copying行为"><a href="#T14：在资源管理类中小心copying行为" class="headerlink" title="T14：在资源管理类中小心copying行为"></a>T14：在资源管理类中小心copying行为</h3>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;第一章-让自己习惯C&quot;&gt;&lt;a href=&quot;#第一章-让自己习惯C&quot; class=&quot;headerlink&quot; title=&quot;第一章 让自己习惯C++&quot;&gt;&lt;/a&gt;第一章 让自己习惯C++&lt;/h2&gt;&lt;h3 id=&quot;T01：视C-为一个语言联邦&quot;&gt;&lt;a href=&quot;#T01：视C-为一个语言联邦&quot; class=&quot;headerlink&quot; title=&quot;T01：视C++为一个语言联邦&quot;&gt;&lt;/a&gt;T01：视C++为一个语言联邦&lt;/h3&gt;&lt;p&gt;略&lt;/p&gt;
&lt;h3 id=&quot;T02：尽量以const-enum-inline替换-define&quot;&gt;&lt;a href=&quot;#T02：尽量以const-enum-inline替换-define&quot; class=&quot;headerlink&quot; title=&quot;T02：尽量以const,enum,inline替换#define&quot;&gt;&lt;/a&gt;T02：尽量以const,enum,inline替换#define&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;单纯的常量，改用const,enums替换&lt;/strong&gt;&lt;br&gt;这样一个宏定义&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;define&lt;/span&gt; ASPECT_RATIO 1.653&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在编译器开始处理源码的时候，这个ASPECT_RATIO符号可能就被预处理器移走了，可能没有获得此符号表，运用这个常量出现一个错误信息的时候，错误信息可能会提到是1.653而不是ASPECT_RATIO，会让人很懵逼&lt;br&gt;可以用这种方式去替换&lt;/p&gt;
    
    </summary>
    
    
      <category term="C++" scheme="http://example.com/categories/C/"/>
    
    
      <category term="C++" scheme="http://example.com/tags/C/"/>
    
      <category term="Effective C++" scheme="http://example.com/tags/Effective-C/"/>
    
  </entry>
  
</feed>
